<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>animation variations — benson perry</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: "Times New Roman", Times, Georgia, serif;
      background: #f8f7f4;
      color: #000;
      min-height: 100vh;
      padding: 40px 30px;
      text-transform: lowercase;
    }
    h1 { font-size: 1.5rem; font-weight: 400; letter-spacing: -0.02em; margin-bottom: 8px; }
    h1 a { color: inherit; text-decoration: none; border-bottom: 1px solid #ccc; }
    h1 a:hover { border-bottom-color: #000; }
    .subtitle { font-size: 0.75rem; color: #999; margin-bottom: 40px; }
    .variation { margin-bottom: 48px; }
    .label { font-size: 0.75rem; font-weight: 400; color: #999; letter-spacing: 0.03em; margin-bottom: 8px; }
    pre.anim {
      font-family: "Courier New", Courier, monospace;
      font-size: 10px;
      line-height: 1.2;
      color: #b0b0a8;
      padding: 0;
      white-space: pre;
      overflow: hidden;
      user-select: none;
      margin-left: -30px;
      margin-right: -30px;
    }
    @media (max-width: 600px) {
      body { padding: 20px 15px; }
      pre.anim { margin-left: -15px; margin-right: -15px; }
    }
  </style>
</head>
<body>
  <h1><a href="/">benson perry</a></h1>
  <div class="subtitle">animation variations</div>

  <div class="variation"><div class="label">1 — flock</div><pre class="anim" id="v1"></pre></div>
  <div class="variation"><div class="label">2 — migration</div><pre class="anim" id="v2"></pre></div>
  <div class="variation"><div class="label">3 — scatter</div><pre class="anim" id="v3"></pre></div>
  <div class="variation"><div class="label">4 — swirl</div><pre class="anim" id="v4"></pre></div>
  <div class="variation"><div class="label">5 — drizzle</div><pre class="anim" id="v5"></pre></div>
  <div class="variation"><div class="label">6 — downpour</div><pre class="anim" id="v6"></pre></div>
  <div class="variation"><div class="label">7 — storm</div><pre class="anim" id="v7"></pre></div>

  <script>
    const H = 7;
    let W = Math.floor(window.innerWidth / 6.02);
    window.addEventListener('resize', () => { W = Math.floor(window.innerWidth / 6.02); });

    function hash(x, y) {
      let h = x + y * 137;
      h = ((h >> 16) ^ h) * 0x45d9f3b | 0;
      h = ((h >> 16) ^ h) * 0x45d9f3b | 0;
      return (h >> 16) ^ h;
    }

    function addStars(g, c, t) {
      const bk = Math.floor(t * 20);
      for (let i = 0; i < 2; i++) {
        const bx = ((hash(bk + i * 9999, i * 2) & 0x7fffffff) % W);
        const by = ((hash(bk + i * 9999, i * 2 + 1) & 0x7fffffff) % H);
        if ((bk % (i === 0 ? 15 : 22)) < 1) { g[by][bx] = '*'; c[by][bx] = '#909090'; }
      }
    }

    function addShooters(g, c, t, shooters) {
      for (const s of shooters) {
        const phase = (t / s.period) % 1;
        if (phase < s.dur) {
          const prog = phase / s.dur;
          const head = s.dir > 0
            ? Math.round(prog * (W + s.len) - s.len)
            : Math.round(W - prog * (W + s.len) + s.len);
          for (let i = 0; i <= s.len; i++) {
            const px = head - i * s.dir;
            if (px >= 0 && px < W && s.y >= 0 && s.y < H) {
              g[s.y][px] = i === 0 ? '*' : '-';
              c[s.y][px] = i === 0 ? '#90c0d0' : '#80a0b0';
            }
          }
        }
      }
    }

    function wingChar(t, i) {
      const p = Math.sin(t * 5 + i * 2.3);
      return p > 0.3 ? 'v' : (p < -0.3 ? '^' : '~');
    }

    const anims = [];
    function reg(id, fn) { anims.push({ el: document.getElementById(id), fn, t: 0 }); }

    function renderAnim(a) {
      const g = Array.from({length: H}, () => new Array(W).fill('\u00B7'));
      const c = Array.from({length: H}, () => new Array(W).fill(''));
      a.fn(g, c, a.t);
      let html = '';
      for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
          html += c[y][x] ? '<span style="color:' + c[y][x] + '">' + g[y][x] + '</span>' : g[y][x];
        }
        if (y < H - 1) html += '\n';
      }
      a.el.innerHTML = html;
    }

    // ---- BIRDS ----

    // 1 — flock: tight group drifting left, strong cohesion, wing flap
    const flock = [];
    for (let i = 0; i < 32; i++) {
      flock.push({
        x: 20 + (Math.random() - 0.5) * 10, y: H / 2 + (Math.random() - 0.5) * 4,
        vx: -0.4 + (Math.random() - 0.5) * 0.2, vy: (Math.random() - 0.5) * 0.2,
      });
    }
    reg('v1', (g, c, t) => {
      addStars(g, c, t);
      for (const b of flock) {
        let sx = 0, sy = 0, ax = 0, ay = 0, cohx = 0, cohy = 0, n = 0;
        for (const o of flock) {
          if (o === b) continue;
          const dx = o.x - b.x, dy = o.y - b.y;
          const d = Math.sqrt(dx * dx + dy * dy);
          if (d < 8 && d > 0) {
            if (d < 2.5) { sx -= dx / d; sy -= dy / d; }
            ax += o.vx; ay += o.vy;
            cohx += o.x; cohy += o.y;
            n++;
          }
        }
        if (n > 0) { ax /= n; ay /= n; cohx = cohx / n - b.x; cohy = cohy / n - b.y; }
        b.vx += sx * 0.05 + ax * 0.03 + cohx * 0.015 - 0.008;
        b.vy += sy * 0.05 + ay * 0.03 + cohy * 0.015;
        if (b.y < 0.5) b.vy += 0.08; if (b.y > H - 1.5) b.vy -= 0.08;
        const spd = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
        if (spd > 1.4) { b.vx *= 1.4 / spd; b.vy *= 1.4 / spd; }
        b.x += b.vx; b.y += b.vy;
        if (b.x < -3) b.x += W + 6;
        if (b.x > W + 3) b.x -= W + 6;
      }
      for (let i = 0; i < flock.length; i++) {
        const b = flock[i];
        const ix = Math.round(b.x), iy = Math.round(b.y);
        if (ix >= 0 && ix < W && iy >= 0 && iy < H) {
          g[iy][ix] = wingChar(t, i);
          c[iy][ix] = '#605040';
        }
      }
      addShooters(g, c, t, [
        { period: 11, dur: 0.12, y: 0, dir: 1, len: 4 },
        { period: 17, dur: 0.09, y: 6, dir: -1, len: 5 },
      ]);
    });

    // 2 — migration: V-formations crossing the screen
    reg('v2', (g, c, t) => {
      addStars(g, c, t);
      const groups = [
        { y: 3, speed: 3.0, size: 7, spacing: 2.2, offset: 0 },
        { y: 1, speed: 2.2, size: 5, spacing: 2.0, offset: 40 },
        { y: 5, speed: 2.6, size: 9, spacing: 2.5, offset: 80 },
        { y: 2, speed: 3.5, size: 4, spacing: 1.8, offset: 120 },
      ];
      for (const grp of groups) {
        const leaderX = ((grp.offset + t * grp.speed) % (W + 60)) - 30;
        for (let i = 0; i < grp.size; i++) {
          const side = i === 0 ? 0 : (i % 2 === 1 ? 1 : -1);
          const rank = Math.ceil(i / 2);
          const bx = Math.round(leaderX - rank * grp.spacing);
          const by = Math.round(grp.y + side * rank * 0.7 + Math.sin(t * 4 + i * 0.8) * 0.3);
          if (bx >= 0 && bx < W && by >= 0 && by < H) {
            g[by][bx] = wingChar(t, i + grp.offset);
            c[by][bx] = '#504838';
          }
        }
      }
      addShooters(g, c, t, [
        { period: 13, dur: 0.11, y: 0, dir: 1, len: 5 },
        { period: 19, dur: 0.08, y: 6, dir: -1, len: 4 },
      ]);
    });

    // 3 — scatter: individual birds and loose pairs crossing at different speeds
    const scatterBirds = [];
    for (let i = 0; i < 22; i++) {
      scatterBirds.push({
        speed: 1.5 + ((hash(i, 10) & 0x7fffffff) % 100) / 25,
        baseY: ((hash(i, 20) & 0x7fffffff) % (H - 2)) + 1,
        dir: (hash(i, 30) & 1) ? 1 : -1,
        offset: ((hash(i, 40) & 0x7fffffff) % 1000) / 5,
        wobbleFreq: 0.6 + ((hash(i, 50) & 0x7fffffff) % 100) / 150,
        wobbleAmp: 0.4 + ((hash(i, 60) & 0x7fffffff) % 100) / 150,
      });
    }
    // pair some birds together
    for (let i = 0; i < scatterBirds.length - 1; i += 4) {
      scatterBirds[i + 1].speed = scatterBirds[i].speed + 0.15;
      scatterBirds[i + 1].baseY = scatterBirds[i].baseY + ((hash(i, 70) & 1) ? 1 : -1);
      scatterBirds[i + 1].dir = scatterBirds[i].dir;
      scatterBirds[i + 1].offset = scatterBirds[i].offset + 2;
    }
    reg('v3', (g, c, t) => {
      addStars(g, c, t);
      for (let i = 0; i < scatterBirds.length; i++) {
        const b = scatterBirds[i];
        const rawX = (t * b.speed + b.offset) % (W + 12) - 6;
        const bx = Math.round(b.dir > 0 ? rawX : W - rawX);
        const by = Math.round(b.baseY + Math.sin(t * b.wobbleFreq + i * 1.7) * b.wobbleAmp);
        if (bx >= 0 && bx < W && by >= 0 && by < H) {
          g[by][bx] = wingChar(t, i);
          c[by][bx] = '#706050';
        }
      }
      addShooters(g, c, t, [
        { period: 10, dur: 0.13, y: 0, dir: 1, len: 4 },
        { period: 16, dur: 0.10, y: 6, dir: -1, len: 3 },
      ]);
    });

    // 4 — swirl: flock chasing a moving attractor, dramatic sweeping shapes
    const swirl = [];
    for (let i = 0; i < 30; i++) {
      swirl.push({
        x: 15 + (Math.random() - 0.5) * 8, y: H / 2 + (Math.random() - 0.5) * 3,
        vx: (Math.random() - 0.5) * 0.3, vy: (Math.random() - 0.5) * 0.2,
      });
    }
    reg('v4', (g, c, t) => {
      addStars(g, c, t);
      const attractX = 18 + Math.sin(t * 0.2) * 14;
      const attractY = H / 2 + Math.sin(t * 0.35) * 2.2;
      for (const b of swirl) {
        let sx = 0, sy = 0, ax = 0, ay = 0, cohx = 0, cohy = 0, n = 0;
        for (const o of swirl) {
          if (o === b) continue;
          const dx = o.x - b.x, dy = o.y - b.y;
          const d = Math.sqrt(dx * dx + dy * dy);
          if (d < 10 && d > 0) {
            if (d < 2.5) { sx -= dx / d; sy -= dy / d; }
            ax += o.vx; ay += o.vy;
            cohx += o.x; cohy += o.y;
            n++;
          }
        }
        if (n > 0) { ax /= n; ay /= n; cohx = cohx / n - b.x; cohy = cohy / n - b.y; }
        const toAx = attractX - b.x, toAy = attractY - b.y;
        b.vx += sx * 0.05 + ax * 0.02 + cohx * 0.012 + toAx * 0.006;
        b.vy += sx * 0.05 + ay * 0.02 + cohy * 0.012 + toAy * 0.008;
        if (b.y < 0.3) b.vy += 0.1; if (b.y > H - 1.3) b.vy -= 0.1;
        if (b.x < 1) b.vx += 0.08; if (b.x > W - 1) b.vx -= 0.08;
        const spd = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
        if (spd > 1.6) { b.vx *= 1.6 / spd; b.vy *= 1.6 / spd; }
        b.x += b.vx; b.y += b.vy;
      }
      for (let i = 0; i < swirl.length; i++) {
        const b = swirl[i];
        const ix = Math.round(b.x), iy = Math.round(b.y);
        if (ix >= 0 && ix < W && iy >= 0 && iy < H) {
          g[iy][ix] = wingChar(t, i);
          c[iy][ix] = '#586068';
        }
      }
      addShooters(g, c, t, [
        { period: 9, dur: 0.14, y: 1, dir: 1, len: 5 },
        { period: 15, dur: 0.10, y: 5, dir: -1, len: 4 },
      ]);
    });

    // ---- RAIN ----

    // 5 — drizzle: light, sparse, gentle diagonal
    reg('v5', (g, c, t) => {
      for (let i = 0; i < 40; i++) {
        const x0 = (hash(i, 100) & 0x7fffffff) % W;
        const speed = 3 + (hash(i, 200) & 0x7fffffff) % 3;
        const offset = ((hash(i, 300) & 0x7fffffff) % 1000) / 20;
        const headY = (t * speed + offset) % (H + 4) - 1;
        const y = Math.floor(headY);
        const x = x0 + Math.floor(headY * 0.4);
        if (y >= 0 && y < H && x >= 0 && x < W) {
          g[y][x] = '.';
          c[y][x] = '#8098a8';
        }
        const y2 = y - 1, x2 = x - Math.floor(0.4);
        if (y2 >= 0 && y2 < H && x2 >= 0 && x2 < W && g[y2][x2] === '\u00B7') {
          c[y2][x2] = '#c0c8d0';
        }
      }
      addShooters(g, c, t, [
        { period: 14, dur: 0.10, y: 1, dir: 1, len: 4 },
        { period: 22, dur: 0.08, y: 5, dir: -1, len: 3 },
      ]);
    });

    // 6 — downpour: heavy, dense, vertical, lots of splashes
    reg('v6', (g, c, t) => {
      for (let i = 0; i < 140; i++) {
        const x0 = (hash(i, 100) & 0x7fffffff) % W;
        const speed = 8 + (hash(i, 200) & 0x7fffffff) % 5;
        const offset = ((hash(i, 300) & 0x7fffffff) % 1000) / 20;
        const len = 2 + (hash(i, 400) & 0x7fffffff) % 2;
        const headY = (t * speed + offset) % (H + len + 2) - len;
        for (let j = 0; j < len; j++) {
          const y = Math.floor(headY) - j;
          if (y >= 0 && y < H && x0 >= 0 && x0 < W) {
            g[y][x0] = j === 0 ? '|' : ':';
            c[y][x0] = j === 0 ? '#5070a0' : '#405880';
          }
        }
      }
      for (let i = 0; i < 18; i++) {
        const sx = ((hash(i, 500) & 0x7fffffff) % W);
        const splashT = (t * 6 + ((hash(i, 600) & 0x7fffffff) % 100) / 8) % 3;
        if (splashT < 0.25) {
          if (sx >= 0 && sx < W) { g[H-1][sx] = '*'; c[H-1][sx] = '#6080a0'; }
          if (sx-1 >= 0) { g[H-1][sx-1] = '.'; c[H-1][sx-1] = '#506878'; }
          if (sx+1 < W) { g[H-1][sx+1] = '.'; c[H-1][sx+1] = '#506878'; }
          if (sx-2 >= 0 && splashT < 0.1) { g[H-1][sx-2] = '.'; c[H-1][sx-2] = '#405060'; }
          if (sx+2 < W && splashT < 0.1) { g[H-1][sx+2] = '.'; c[H-1][sx+2] = '#405060'; }
        }
      }
      addShooters(g, c, t, [
        { period: 12, dur: 0.11, y: 0, dir: 1, len: 5 },
        { period: 18, dur: 0.09, y: 3, dir: -1, len: 4 },
      ]);
    });

    // 7 — storm: diagonal wind, frequent lightning, splashes
    reg('v7', (g, c, t) => {
      const windStrength = 0.8 + Math.sin(t * 0.3) * 0.3;
      for (let i = 0; i < 100; i++) {
        const x0 = (hash(i, 100) & 0x7fffffff) % (W + 20);
        const speed = 7 + (hash(i, 200) & 0x7fffffff) % 5;
        const offset = ((hash(i, 300) & 0x7fffffff) % 1000) / 20;
        const len = 1 + (hash(i, 400) & 0x7fffffff) % 3;
        const headY = (t * speed + offset) % (H + len + 3) - len;
        for (let j = 0; j < len; j++) {
          const y = Math.floor(headY) - j;
          const x = Math.floor(x0 - headY * windStrength + j * windStrength);
          if (y >= 0 && y < H && x >= 0 && x < W) {
            g[y][x] = j === 0 ? '/' : ':';
            c[y][x] = j === 0 ? '#506080' : '#404858';
          }
        }
      }
      for (let i = 0; i < 10; i++) {
        const sx = ((hash(i, 500) & 0x7fffffff) % W);
        const splashT = (t * 5 + ((hash(i, 600) & 0x7fffffff) % 100) / 8) % 4;
        if (splashT < 0.2 && H - 1 >= 0) {
          if (sx < W) { g[H-1][sx] = '*'; c[H-1][sx] = '#607090'; }
          if (sx-1 >= 0) { g[H-1][sx-1] = '.'; c[H-1][sx-1] = '#506070'; }
          if (sx+1 < W) { g[H-1][sx+1] = '.'; c[H-1][sx+1] = '#506070'; }
        }
      }
      const lPhase = Math.floor(t * 0.7);
      const lFrac = (t * 0.7) % 1;
      if (lFrac < 0.02) {
        const ly = (hash(lPhase, 888) & 0x7fffffff) % H;
        for (let x = 0; x < W; x++) {
          if ((hash(x + lPhase * 1000, 999) & 0x7fffffff) % 3 !== 0) {
            g[ly][x] = '-'; c[ly][x] = '#d0d0e0';
          }
        }
      }
      if (lFrac > 0.02 && lFrac < 0.04) {
        const ly2 = ((hash(lPhase, 777) & 0x7fffffff) % H);
        for (let x = 0; x < W; x++) {
          if ((hash(x + lPhase * 2000, 998) & 0x7fffffff) % 4 !== 0) {
            g[ly2][x] = '-'; c[ly2][x] = '#b0b0c0';
          }
        }
      }
      addShooters(g, c, t, [
        { period: 8, dur: 0.15, y: 1, dir: 1, len: 6 },
        { period: 14, dur: 0.10, y: 4, dir: -1, len: 5 },
      ]);
    });

    // master loop
    for (const a of anims) { a.t = 0.03; renderAnim(a); }
    let last = 0;
    requestAnimationFrame(function loop(ts) {
      if (ts - last > 50) {
        last = ts;
        for (const a of anims) { a.t += 0.03; renderAnim(a); }
      }
      requestAnimationFrame(loop);
    });
  </script>
</body>
</html>
